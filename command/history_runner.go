package command

import (
	"context"
	"crypto/md5"
	"encoding/hex"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/minamijoyo/tfmigrate/config"
	"github.com/minamijoyo/tfmigrate/history"
	"github.com/minamijoyo/tfmigrate/tfmigrate"
)

// HistoryRunner is a history-aware runner.
// It allows us to apply all unapplied migrations and save them to history.
type HistoryRunner struct {
	// A path to migration file. This is optional.
	// If set, run a single migration and save it to history.
	// If not set, run all unapplied migrations and save them to history.
	filename string
	// A global configuration.
	config *config.TfmigrateConfig
	// A option to share across migrations.
	option *tfmigrate.MigratorOption
	// A controller which manages history.
	hc *history.Controller
}

// NewHistoryRunner returns a new HistoryRunner instance.
func NewHistoryRunner(ctx context.Context, filename string, config *config.TfmigrateConfig, option *tfmigrate.MigratorOption) (*HistoryRunner, error) {
	hc, err := history.NewController(ctx, config.MigrationDir, config.History)
	if err != nil {
		return nil, err
	}

	r := &HistoryRunner{
		filename: filename,
		config:   config,
		option:   option,
		hc:       hc,
	}

	return r, nil
}

// Plan plans migrations with history-aware mode.
// If a filename is set, run a single migration.
// If not set, run all unapplied migrations.
func (r *HistoryRunner) Plan(ctx context.Context) error {
	if len(r.filename) != 0 {
		// file mode
		return r.planFile(ctx, r.filename)
	}

	// directory mode
	return r.planDir(ctx)
}

// planFile plans a single migration.
func (r *HistoryRunner) planFile(ctx context.Context, filename string) error {
	if r.hc.AlreadyApplied(filename) {
		return fmt.Errorf("a migration has already been applied: %s", filename)
	}

	fr, err := NewFileRunner(filename, r.config, r.option)
	if err != nil {
		log.Printf("[ERROR] [runner] failed to plan: %s\n", filename)
		return err
	}

	return fr.Plan(ctx)
}

// planDir plans all unapplied migrations.
func (r *HistoryRunner) planDir(ctx context.Context) error {
	// Update missing MD5 hashes for backward compatibility
	err := r.updateMissingMD5Hashes(ctx)
	if err != nil {
		return err
	}

	// Validate that there are no duplicate migrations before planning
	err = r.validateNoDuplicates(ctx)
	if err != nil {
		return err
	}

	unapplied := r.hc.UnappliedMigrations()

	if len(unapplied) == 0 {
		log.Printf("[INFO] [runner] no unapplied migrations\n")
		return nil
	}
	log.Printf("[INFO] [runner] unapplied migration files: %v\n", unapplied)

	for _, filename := range unapplied {
		err := r.planFile(ctx, filename)
		if err != nil {
			return err
		}
	}

	return nil
}

// Apply applies migrations and save them to history.
// If a filename is set, run a single migration.
// If not set, run all unapplied migrations.
func (r *HistoryRunner) Apply(ctx context.Context) (err error) {
	// save history on exit
	beforeLen := r.hc.HistoryLength()
	defer func() {
		// if the number of records in history doesn't change,
		// we don't want to update a timestamp of history file.
		afterLen := r.hc.HistoryLength()
		log.Printf("[DEBUG] [runner] length of history records: beforeLen = %d, afterLen = %d\n", beforeLen, afterLen)
		if beforeLen == afterLen {
			return
		}

		// be sure not to overwrite an original error generated by outside of defer
		log.Print("[INFO] [runner] save history\n")
		serr := r.hc.Save(ctx)
		if serr == nil {
			log.Print("[INFO] [runner] history saved\n")
			return
		}

		// return a named error from defer
		log.Printf("[ERROR] [runner] failed to save history. The history may be inconsistent\n")
		if err == nil {
			err = fmt.Errorf("apply succeed, but failed to save history: %v", serr)
			return
		}
		err = fmt.Errorf("failed to save history: %v, failed to apply: %v", serr, err)
	}()

	if len(r.filename) != 0 {
		// file mode
		err = r.applyFile(ctx, r.filename)
		return err
	}

	// Validate that there are no duplicate migrations before applying
	err = r.updateMissingMD5Hashes(ctx)
	if err != nil {
		return err
	}

	err = r.validateNoDuplicates(ctx)
	if err != nil {
		return err
	}

	// directory mode
	err = r.applyDir(ctx)
	return err
}

// applyFile applies a single migration.
func (r *HistoryRunner) applyFile(ctx context.Context, filename string) error {
	if r.hc.AlreadyApplied(filename) {
		return fmt.Errorf("a migration has already been applied: %s", filename)
	}

	fr, err := NewFileRunner(filename, r.config, r.option)
	if err != nil {
		return err
	}

	err = fr.Apply(ctx)
	if err != nil {
		log.Printf("[ERROR] [runner] failed to apply: %s\n", filename)
		return err
	}

	// Compute MD5 hash of the migration file
	path := filepath.Join(r.config.MigrationDir, filename)
	source, err := os.ReadFile(path)
	if err != nil {
		return fmt.Errorf("failed to read migration file for hash computation %s: %v", filename, err)
	}
	hash := md5.Sum(source)
	md5Hash := hex.EncodeToString(hash[:])

	mc := fr.MigrationConfig()
	log.Printf("[INFO] [runner] add a record to history: %s\n", filename)
	r.hc.AddRecord(filename, mc.Type, mc.Name, md5Hash, nil)

	return nil
}

// applyDir applies all unapplied migrations.
func (r *HistoryRunner) applyDir(ctx context.Context) (err error) {
	unapplied := r.hc.UnappliedMigrations()

	if len(unapplied) == 0 {
		log.Printf("[INFO] [runner] no unapplied migrations\n")
		return nil
	}
	log.Printf("[INFO] [runner] unapplied migration files: %v\n", unapplied)

	for _, filename := range unapplied {
		err := r.applyFile(ctx, filename)
		if err != nil {
			return err
		}
	}

	return nil
}

// validateNoDuplicates validates that there are no duplicate migrations by name.
// It checks for duplicates in:
// 1. Local migration files (same migration name in different files)
// 2. Remote state vs local migrations (migration name already exists in history)
// 3. MD5 hash validation (migration files haven't been modified after application)
// 4. Duplicate MD5 hashes in history (same content applied multiple times)
// Returns an error if duplicates are found.
func (r *HistoryRunner) validateNoDuplicates(ctx context.Context) error {
	// Load all migration files and extract their names and compute hashes
	localMigrationNames := make(map[string][]string) // migration name -> list of files containing it
	localMigrationHashes := make(map[string]string)  // filename -> md5 hash

	for _, filename := range r.hc.Migrations() {
		path := filepath.Join(r.config.MigrationDir, filename)

		// Read and parse the migration file to get its name
		source, err := os.ReadFile(path)
		if err != nil {
			return fmt.Errorf("failed to read migration file %s: %v", filename, err)
		}

		// Compute MD5 hash
		hash := md5.Sum(source)
		md5Hash := hex.EncodeToString(hash[:])
		localMigrationHashes[filename] = md5Hash

		mc, err := config.ParseMigrationFile(filename, source)
		if err != nil {
			return fmt.Errorf("failed to parse migration file %s: %v", filename, err)
		}

		migrationName := mc.Name
		localMigrationNames[migrationName] = append(localMigrationNames[migrationName], filename)
	}

	// Check for local duplicates (same migration name in multiple files)
	var localDuplicates []string
	for migrationName, files := range localMigrationNames {
		if len(files) > 1 {
			localDuplicates = append(localDuplicates, fmt.Sprintf("migration name '%s' appears in files: %v", migrationName, files))
		}
	}

	if len(localDuplicates) > 0 {
		return fmt.Errorf("duplicate migration names found locally:\n  %s", strings.Join(localDuplicates, "\n  "))
	}

	// Get history records for validation
	historyRecords := r.hc.Records()

	// Check for remote duplicates (migration name already exists in history)
	var remoteDuplicates []string
	for migrationName, files := range localMigrationNames {
		// Check if any record in history has the same migration name
		for historyFilename, record := range historyRecords {
			if record.Name == migrationName && !contains(files, historyFilename) {
				remoteDuplicates = append(remoteDuplicates, fmt.Sprintf("migration name '%s' in file '%s' already exists in history (applied in '%s')", migrationName, files[0], historyFilename))
			}
		}
	}

	if len(remoteDuplicates) > 0 {
		return fmt.Errorf("duplicate migration names found in remote state:\n  %s", strings.Join(remoteDuplicates, "\n  "))
	}

	// Check for MD5 hash mismatches (migration files modified after application)
	var hashMismatches []string
	for historyFilename, record := range historyRecords {
		if localHash, exists := localMigrationHashes[historyFilename]; exists {
			// Skip validation if no hash stored (backward compatibility)
			if record.MD5Hash != "" && localHash != record.MD5Hash {
				hashMismatches = append(hashMismatches, fmt.Sprintf("migration file '%s' has been modified after application (expected hash: %s, current hash: %s)", historyFilename, record.MD5Hash, localHash))
			}
		}
	}

	if len(hashMismatches) > 0 {
		return fmt.Errorf("migration file integrity check failed:\n  %s", strings.Join(hashMismatches, "\n  "))
	}

	// Check for duplicate MD5 hashes in history (same content applied multiple times)
	historyHashToFiles := make(map[string][]string)
	for historyFilename, record := range historyRecords {
		if record.MD5Hash != "" {
			historyHashToFiles[record.MD5Hash] = append(historyHashToFiles[record.MD5Hash], historyFilename)
		}
	}

	var duplicateHashes []string
	for hash, files := range historyHashToFiles {
		if len(files) > 1 {
			duplicateHashes = append(duplicateHashes, fmt.Sprintf("duplicate content found in history files: %v (hash: %s)", files, hash))
		}
	}

	if len(duplicateHashes) > 0 {
		return fmt.Errorf("duplicate migration content found in history:\n  %s", strings.Join(duplicateHashes, "\n  "))
	}

	return nil
}

// contains checks if a slice contains a specific string
func contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}

// updateMissingMD5Hashes updates history records that are missing MD5 hashes.
// This provides backward compatibility for migration files that were applied before MD5 validation was implemented.
func (r *HistoryRunner) updateMissingMD5Hashes(ctx context.Context) error {
	updated := false
	historyRecords := r.hc.Records()

	for historyFilename, record := range historyRecords {
		// Skip if hash already exists
		if record.MD5Hash != "" {
			continue
		}

		// Check if the migration file still exists locally
		path := filepath.Join(r.config.MigrationDir, historyFilename)
		if _, err := os.Stat(path); os.IsNotExist(err) {
			log.Printf("[DEBUG] [runner] migration file '%s' no longer exists, skipping MD5 hash update\n", historyFilename)
			continue
		}

		// Read the file and compute MD5 hash
		source, err := os.ReadFile(path)
		if err != nil {
			log.Printf("[DEBUG] [runner] failed to read migration file '%s' for MD5 update: %v\n", historyFilename, err)
			continue
		}

		hash := md5.Sum(source)
		md5Hash := hex.EncodeToString(hash[:])
		
		// Use AddRecord method to update the history
		r.hc.AddRecord(historyFilename, record.Type, record.Name, md5Hash, &record.AppliedAt)
		updated = true
		log.Printf("[INFO] [runner] updated MD5 hash for existing migration: %s\n", historyFilename)
	}

	// Save the updated history if any records were modified
	if updated {
		log.Printf("[INFO] [runner] saving updated history with MD5 hashes\n")
		return r.hc.Save(ctx)
	}

	return nil
}
